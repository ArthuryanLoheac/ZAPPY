<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: docs/node_modules/form-data-encoder Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_b01c18dea727fbdb8f76b25f44b75eb5.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">form-data-encoder Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Encode <code>FormData</code> content into the <code>multipart/form-data</code> format</p>
<p><a href="https://codecov.io/github/octet-stream/form-data-encoder?branch=master"><img src="https://codecov.io/github/octet-stream/form-data-encoder/coverage.svg?branch=master" alt="Code Coverage" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/octet-stream/form-data-encoder/actions/workflows/ci.yml"><img src="https://github.com/octet-stream/form-data-encoder/workflows/CI/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/octet-stream/form-data-encoder/actions/workflows/eslint.yml"><img src="https://github.com/octet-stream/form-data-encoder/workflows/ESLint/badge.svg" alt="ESLint" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md8030"></a>
Requirements</h1>
<ul>
<li>Node.js v14.17 or higher;</li>
<li>Runtime should support <code>TextEncoder</code>, <code>TextDecoder</code>, <code>WeakMap</code>, <code>WeakSet</code> and async generator functions;</li>
<li>For TypeScript users: tsc v4.3 or higher.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8031"></a>
Installation</h1>
<p>You can install this package using npm:</p>
<div class="fragment"><div class="line">npm install form-data-encoder</div>
</div><!-- fragment --><p>Or yarn:</p>
<div class="fragment"><div class="line">yarn add form-data-encoder</div>
</div><!-- fragment --><p>Or pnpm:</p>
<div class="fragment"><div class="line">pnpm add form-data-encoder</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8032"></a>
Usage</h1>
<ol type="1">
<li>To start the encoding process, you need to create a new Encoder instance with the FormData you want to encode:</li>
</ol>
<div class="fragment"><div class="line">import {Readable} from &quot;stream&quot;</div>
<div class="line"> </div>
<div class="line">import {FormData, File} from &quot;formdata-node&quot;</div>
<div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line"> </div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;greeting&quot;, &quot;Hello, World!&quot;)</div>
<div class="line">form.set(&quot;file&quot;, new File([&quot;On Soviet Moon landscape see binoculars through YOU&quot;], &quot;file.txt&quot;))</div>
<div class="line"> </div>
<div class="line">const encoder = new FormDataEncoder(form)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line"> </div>
<div class="line">  // Set request headers provided by the Encoder.</div>
<div class="line">  // The `headers` property has `Content-Type` and `Content-Length` headers.</div>
<div class="line">  headers: encoder.headers,</div>
<div class="line"> </div>
<div class="line">  // Create a Readable stream from the Encoder.</div>
<div class="line">  // You can omit usage of `Readable.from` for HTTP clients whose support async iterables in request body.</div>
<div class="line">  // The Encoder will yield FormData content portions encoded into the multipart/form-data format as node-fetch consumes the stream.</div>
<div class="line">  body: Readable.from(encoder.encode()) // or just Readable.from(encoder)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const response = await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
<div class="line"> </div>
<div class="line">console.log(await response.json())</div>
</div><!-- fragment --><ol type="1">
<li>Encoder support different spec-compatible FormData implementations. Let's try it with <a href="https://github.com/jimmywarting/FormData"><code>formdata-polyfill</code></a>:</li>
</ol>
<div class="fragment"><div class="line">import {Readable} from &quot;stream&quot;</div>
<div class="line"> </div>
<div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line">import {FormData} from &quot;formdata-polyfill/esm-min.js&quot;</div>
<div class="line">import {File} from &quot;fetch-blob&quot; // v3</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;field&quot;, &quot;Some value&quot;)</div>
<div class="line">form.set(&quot;file&quot;, new File([&quot;File content goes here&quot;], &quot;file.txt&quot;))</div>
<div class="line"> </div>
<div class="line">const encoder = new FormDataEncoder(form)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line">  headers: encoder.headers,</div>
<div class="line">  body: Readable.from(encoder)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
</div><!-- fragment --><ol type="1">
<li>Because the Encoder is iterable (it has both Symbol.asyncIterator and Symbol.iterator methods), you can use it with different targets. Let's say you want to convert FormData content into <code>Blob</code>, for that you can write a function like this:</li>
</ol>
<div class="fragment"><div class="line">import {Readable} from &quot;stream&quot;</div>
<div class="line"> </div>
<div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line"> </div>
<div class="line">import {FormData, File, Blob, fileFromPath} from &quot;formdata-node&quot;</div>
<div class="line"> </div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;field&quot;, &quot;Just a random string&quot;)</div>
<div class="line">form.set(&quot;file&quot;, new File([&quot;Using files is class amazing&quot;], &quot;file.txt&quot;))</div>
<div class="line">form.set(&quot;fileFromPath&quot;, await fileFromPath(&quot;path/to/a/file.txt&quot;))</div>
<div class="line"> </div>
<div class="line">// Note 1: When using with native Blob or fetch-blob@2 you might also need to generate boundary string for your FormDataEncoder instance</div>
<div class="line">// because Blob will lowercase value of the `type` option and default boundary generator produces a string with both lower and upper cased alphabetical characters. Math.random() should be enough to fix this:</div>
<div class="line">// const encoder = new FormDataEncoder(form, String(Math.random()))</div>
<div class="line">const encoder = new FormDataEncoder(form)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line"> </div>
<div class="line">  // Note 2: To use this approach with fetch-blob@2 you probably gonna need to convert the encoder parts output to an array first:</div>
<div class="line">  // new Blob([...encoder], {type: encoder.contentType})</div>
<div class="line">  body: new Blob(encoder, {type: encoder.contentType})</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const response = await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
<div class="line"> </div>
<div class="line">console.log(await response.json())</div>
</div><!-- fragment --><ol type="1">
<li>Here's FormData to Blob conversion with async-iterator approach:</li>
</ol>
<div class="fragment"><div class="line">import {FormData} from &quot;formdata-polyfill/esm-min.js&quot;</div>
<div class="line">import {blobFrom} from &quot;fetch-blob/from.js&quot;</div>
<div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line"> </div>
<div class="line">import Blob from &quot;fetch-blob&quot;</div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">// This approach may require much more RAM compared to the previous one, but it works too.</div>
<div class="line">async function toBlob(form) {</div>
<div class="line">  const encoder = new Encoder(form)</div>
<div class="line">  const chunks = []</div>
<div class="line"> </div>
<div class="line">  for await (const chunk of encoder) {</div>
<div class="line">    chunks.push(chunk)</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return new Blob(chunks, {type: encoder.contentType})</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;name&quot;, &quot;John Doe&quot;)</div>
<div class="line">form.set(&quot;avatar&quot;, await blobFrom(&quot;path/to/an/avatar.png&quot;), &quot;avatar.png&quot;)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line">  body: await toBlob(form)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
</div><!-- fragment --><ol type="1">
<li>Another way to convert FormData parts to blob using <code>form-data-encoder</code> is making a Blob-ish class:</li>
</ol>
<div class="fragment"><div class="line">import {Readable} from &quot;stream&quot;</div>
<div class="line"> </div>
<div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line">import {FormData} from &quot;formdata-polyfill/esm-min.js&quot;</div>
<div class="line">import {blobFrom} from &quot;fetch-blob/from.js&quot;</div>
<div class="line"> </div>
<div class="line">import Blob from &quot;fetch-blob&quot;</div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">class BlobDataItem {</div>
<div class="line">  constructor(encoder) {</div>
<div class="line">    this.#encoder = encoder</div>
<div class="line">    this.#size = encoder.headers[&quot;Content-Length&quot;]</div>
<div class="line">    this.#type = encoder.headers[&quot;Content-Type&quot;]</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  get type() {</div>
<div class="line">    return this.#type</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  get size() {</div>
<div class="line">    return this.#size</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  stream() {</div>
<div class="line">    return Readable.from(this.#encoder)</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  get [Symbol.toStringTag]() {</div>
<div class="line">    return &quot;Blob&quot;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;name&quot;, &quot;John Doe&quot;)</div>
<div class="line">form.set(&quot;avatar&quot;, await blobFrom(&quot;path/to/an/avatar.png&quot;), &quot;avatar.png&quot;)</div>
<div class="line"> </div>
<div class="line">const encoder = new FormDataEncoder(form)</div>
<div class="line"> </div>
<div class="line">// Note that node-fetch@2 performs more strictness tests for Blob objects, so you may need to do extra steps before you set up request body (like, maybe you&#39;ll need to instaniate a Blob with BlobDataItem as one of its blobPart)</div>
<div class="line">const blob = new BlobDataItem(enocoder) // or new Blob([new BlobDataItem(enocoder)], {type: encoder.contentType})</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line">  body: blob</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
</div><!-- fragment --><ol type="1">
<li>In this example we will pull FormData content into the ReadableStream:</li>
</ol>
<div class="fragment"><div class="line"> // This module is only necessary when you targeting Node.js or need web streams that implement Symbol.asyncIterator</div>
<div class="line">import {ReadableStream} from &quot;web-streams-polyfill/ponyfill/es2018&quot;</div>
<div class="line"> </div>
<div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line">import {FormData} from &quot;formdata-node&quot;</div>
<div class="line"> </div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">function toReadableStream(encoder) {</div>
<div class="line">  const iterator = encoder.encode()</div>
<div class="line"> </div>
<div class="line">  return new ReadableStream({</div>
<div class="line">    async pull(controller) {</div>
<div class="line">      const {value, done} = await iterator.next()</div>
<div class="line"> </div>
<div class="line">      if (done) {</div>
<div class="line">        return controller.close()</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      controller.enqueue(value)</div>
<div class="line">    }</div>
<div class="line">  })</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;field&quot;, &quot;My hovercraft is full of eels&quot;)</div>
<div class="line"> </div>
<div class="line">const encoder = new FormDataEncoder(form)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line">  headers: encoder.headers,</div>
<div class="line">  body: toReadableStream(encoder)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Note that this example requires `fetch` to support Symbol.asyncIterator, which node-fetch lacks of (but will support eventually)</div>
<div class="line">await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
</div><!-- fragment --><ol type="1">
<li>Speaking of async iterables - if HTTP client supports them, you can use encoder like this:</li>
</ol>
<div class="fragment"><div class="line">import {FormDataEncoder} from &quot;form-data-encoder&quot;</div>
<div class="line">import {FormData} from &quot;formdata-node&quot;</div>
<div class="line"> </div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;field&quot;, &quot;My hovercraft is full of eels&quot;)</div>
<div class="line"> </div>
<div class="line">const encoder = new FormDataEncoder(form)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line">  headers: encoder.headers,</div>
<div class="line">  body: encoder</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
</div><!-- fragment --><ol type="1">
<li>...And for those client whose supporting form-data-encoder out of the box, the usage will be much, much more simpler:</li>
</ol>
<div class="fragment"><div class="line">import {FormData} from &quot;formdata-node&quot; // Or any other spec-compatible implementation</div>
<div class="line"> </div>
<div class="line">import fetch from &quot;node-fetch&quot;</div>
<div class="line"> </div>
<div class="line">const form = new FormData()</div>
<div class="line"> </div>
<div class="line">form.set(&quot;field&quot;, &quot;My hovercraft is full of eels&quot;)</div>
<div class="line"> </div>
<div class="line">const options = {</div>
<div class="line">  method: &quot;post&quot;,</div>
<div class="line">  body: form</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Note that node-fetch does NOT support form-data-encoder</div>
<div class="line">await fetch(&quot;https://httpbin.org/post&quot;, options)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8033"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md8034"></a>
<code>class FormDataEncoder</code></h2>
<h4><a class="anchor" id="autotoc_md8035"></a>
<code>constructor(form[, boundary, options]) -&gt; {FormDataEncoder}</code></h4>
<ul>
<li>**{FormDataLike}** form - FormData object to encode. This object must be a spec-compatible FormData implementation.</li>
<li>**{string}** [boundary] - An optional boundary string that will be used by the encoder. If there's no boundary string is present, FormDataEncoder will generate it automatically.</li>
<li>**{object}** [options] - FormDataEncoder options.</li>
<li>**{boolean}** [options.enableAdditionalHeaders = false] - When enabled, the encoder will emit additional per part headers, such as <code>Content-Length</code>. Please note that the web clients do not include these, so when enabled this option might cause an error if <code>multipart/form-data</code> does not consider additional headers.</li>
</ul>
<p>Creates a <code>multipart/form-data</code> encoder.</p>
<h3><a class="anchor" id="autotoc_md8036"></a>
Instance properties</h3>
<h4><a class="anchor" id="autotoc_md8037"></a>
<code>boundary -&gt; {string}</code></h4>
<p>Returns boundary string.</p>
<h4><a class="anchor" id="autotoc_md8038"></a>
<code>contentType -&gt; {string}</code></h4>
<p>Returns Content-Type header.</p>
<h4><a class="anchor" id="autotoc_md8039"></a>
<code>contentLength -&gt; {string}</code></h4>
<p>Return Content-Length header.</p>
<h4><a class="anchor" id="autotoc_md8040"></a>
<code>headers -&gt; {object}</code></h4>
<p>Returns headers object with Content-Type and Content-Length header.</p>
<h3><a class="anchor" id="autotoc_md8041"></a>
Instance methods</h3>
<h4><a class="anchor" id="autotoc_md8042"></a>
<code>values() -&gt; {Generator&lt;Uint8Array | FileLike, void, undefined&gt;}</code></h4>
<p>Creates an iterator allowing to go through form-data parts (with metadata). This method <b>will not</b> read the files.</p>
<h4><a class="anchor" id="autotoc_md8043"></a>
<code>encode() -&gt; {AsyncGenerator&lt;Uint8Array, void, undefined&gt;}</code></h4>
<p>Creates an async iterator allowing to perform the encoding by portions. This method <b>will</b> also read files.</p>
<h4><a class="anchor" id="autotoc_md8044"></a>
<code>[Symbol.iterator]() -&gt; {Generator&lt;Uint8Array | FileLike, void, undefined&gt;}</code></h4>
<p>An alias for <code>Encoder#values()</code> method.</p>
<h4><a class="anchor" id="autotoc_md8045"></a>
<code>[Symbol.asyncIterator]() -&gt; {AsyncGenerator&lt;Uint8Array, void, undefined&gt;}</code></h4>
<p>An alias for <code>Encoder#encode()</code> method.</p>
<h2><a class="anchor" id="autotoc_md8046"></a>
<code>isFile(value) -&gt; {boolean}</code></h2>
<p>Check if a value is File-ish object.</p>
<ul>
<li>**{unknown}** value - a value to test</li>
</ul>
<h2><a class="anchor" id="autotoc_md8047"></a>
<code>isFormData(value) -&gt; {boolean}</code></h2>
<p>Check if a value is FormData-ish object.</p>
<ul>
<li>**{unknown}** value - a value to test </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_49e56c817e5e54854c35e136979f97ca.html">docs</a></li><li class="navelem"><a class="el" href="dir_a0409b32ef7fd26e7246cf83548265be.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_b01c18dea727fbdb8f76b25f44b75eb5.html">form-data-encoder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>

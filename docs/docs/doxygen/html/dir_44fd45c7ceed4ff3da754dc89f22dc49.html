<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: docs/node_modules/react-loadable Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dir_44fd45c7ceed4ff3da754dc89f22dc49.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">react-loadable Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><b>IMPORTANT</b>: this is a minimalistic fork to solve the <code>componentWillMount</code> warning for the <a href="https://github.com/facebook/docusaurus">facebook/docusaurus</a> project.</p>
<p>v6.0 also adds support for React 18.3 / React 19, and removes the useless prop-type dependency.</p>
<p>We don't plan to support/maintain this project, just get rid of the deprecation warnings for our own needs. It is provided as-is, and we won't accept PRs.</p>
<hr  />
<p><img src="http://thejameskyle.com/img/react-loadable-header.png" alt="React Loadable" class="inline"/></p>
<blockquote class="doxtable">
<p>A higher order component for loading components with dynamic imports. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md18267"></a>
Install</h2>
<div class="fragment"><div class="line">yarn add react-loadable</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18268"></a>
Example</h2>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line">import Loading from &#39;./my-loading-component&#39;;</div>
<div class="line"> </div>
<div class="line">const LoadableComponent = Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./my-component&#39;),</div>
<div class="line">  loading: Loading,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">export default class App extends React.Component {</div>
<div class="line">  render() {</div>
<div class="line">    return &lt;LoadableComponent/&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18269"></a>
Happy Customers:</h2>
<ul>
<li><a href="https://twitter.com/matzatorski/status/872059865350406144">"I'm obsessed with this right now: CRA with React Router v4 and react-loadable. Free code splitting, this is so easy."</a></li>
<li><a href="https://twitter.com/AdamRackis/status/846593080992153600">"Oh hey - using loadable component I knocked 13K off my initial load. Easy win!"</a></li>
<li><a href="https://github.com/quran/quran.com-frontend/pull/701#issuecomment-287908551">"Had a look and its awesome. shaved like 50kb off our main bundle."</a></li>
<li><a href="https://twitter.com/mxstbr/status/922375575217627136">"I've got that server-side rendering + code splitting + PWA ServiceWorker caching setup done ðŸ˜Ž (thanks to react-loadable). Now our frontend is super fast."</a></li>
<li><a href="https://twitter.com/evgenyrodionov/status/958821614644269057">"Using react-loadable went from 221.28 KB â†’ 115.76 KB @ main bundle. Fucking awesome and very simple API."</a></li>
<li><a href="https://github.com/jamiebuilds/react-loadable/pull/181">"We've reduced our entry chunk by a lot &amp; reduced initial load time by ~50%!"</a></li>
<li><a href="https://github.com/jamiebuilds/react-loadable/pull/180/">"React-loadable is killer! We've decreased our load size by over 50kb with only 2 files! Can't wait to see how much lower it will go."</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md18270"></a>
Users</h2>
<ul>
<li><a href="https://www.flooringstores.com">AdHawk / Flooring Stores</a></li>
<li><a href="https://www.akutbolig.dk">Akutbolig.dk</a></li>
<li><a href="https://www.analog.cafe">Analog.Cafe</a></li>
<li><a href="https://ambrosus.com">Ambrosus</a></li>
<li><a href="https://github.com/appbaseio/reactivesearch">Appbase.io</a></li>
<li><a href="https://www.atlassian.com/">Atlassian</a></li>
<li><a href="https://github.com/BBC-News/simorgh">BBC News</a></li>
<li><a href="https://www.blytzpay.com">Blytzpay</a></li>
<li><a href="https://cleartax.in">ClearTax</a></li>
<li><a href="https://www.cloudflare.com">Cloudflare</a></li>
<li><a href="https://chibaki.co">Chibaki</a></li>
<li><a href="https://compass.com">Compass</a></li>
<li><a href="https://www.curio.org">Curio</a></li>
<li><a href="https://www.delivery.com">Delivery.com</a></li>
<li><a href="https://www.doctor.com/">Doctor.com</a></li>
<li><a href="https://github.com/dollarshaveclub">Dollar Shave Club</a></li>
<li><a href="https://dresez.pk/">Dresez</a></li>
<li><a href="https://www.edcast.com/">Edcast</a></li>
<li><a href="https://evidation.com/">Evidation Health</a></li>
<li><a href="https://flexport.com/">Flexport</a></li>
<li><a href="https://flyhomes.com">Flyhomes</a></li>
<li><a href="https://gogoair.com">Gogo</a></li>
<li><a href="https://gofore.com/en/home/">Gofore</a></li>
<li><a href="https://www.graana.com/">Graana</a></li>
<li><a href="https://localie.co/en">Localie</a></li>
<li><a href="https://github.com/MCS-Lite">MediaTek MCS-Lite</a></li>
<li><a href="https://www.goniyo.com/">NiYO Solutions Inc.</a></li>
<li><a href="https://www.officepulse.in/">Officepulse</a></li>
<li><a href="https://pagespeed.green/">PageSpeed Green</a></li>
<li><a href="https://www.perxtech.com/">Perx</a></li>
<li><a href="https://public.plottu.com">Plottu</a></li>
<li><a href="https://reformma.com.br">reformma</a></li>
<li><a href="https://render.com">Render</a></li>
<li><a href="https://shift.com">Shift</a></li>
<li><a href="https://snipit.io">Snipit</a></li>
<li><a href="https://spectrum.chat">Spectrum.chat</a></li>
<li><a href="https://superblocks.com">Superblocks</a></li>
<li><a href="https://sprintboards.io">Sprint Boards</a></li>
<li><a href="https://talentpair.com">Talentpair</a></li>
<li><a href="https://tinder.com/">Tinder</a></li>
<li><a href="https://unsplash.com/">Unsplash</a></li>
<li><a href="https://waveapps.com/">Wave</a></li>
<li><a href="https://wuzzuf.net/">WUZZUF</a></li>
<li><a href="https://wxb.com/wxpush">Wxb</a></li>
</ul>
<blockquote class="doxtable">
<p><em>If your company or project is using React Loadable, please open a PR and add yourself to this list (in alphabetical order please)</em> </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md18271"></a>
Also See:</h2>
<ul>
<li><a href="https://github.com/stratiformltd/react-loadable-visibility"><code>react-loadable-visibility</code></a> - Building on top of and keeping the same API as <code>react-loadable</code>, this library enables you to load content that is visible on the screen.</li>
<li><a href="https://github.com/themgoncalves/react-loadable-ssr-addon"><code>react-loadable-ssr-addon</code></a> - Server Side Render add-on for <code>react-loadable</code>. Discover &amp; load automatically dynamically all files dependencies, e.g. splitted chunks, css, etc.</li>
</ul>
<h2><img src="http://thejameskyle.com/img/react-loadable-guide.png" alt="GUIDE" class="inline"/>   <small>Guide</small> </h2>
<p>So you've got your React app, you're bundling it with Webpack, and things are going smooth. But then one day you notice your app's bundle is getting so big that it's slowing things down.</p>
<p>It's time to start code-splitting your app!</p>
<p><img src="http://thejameskyle.com/img/react-loadable-split-bundles.png" alt="A single giant bundle vs multiple smaller bundles" class="inline"/></p>
<p>Code-splitting is the process of taking one large bundle containing your entire app, and splitting them up into multiple smaller bundles which contain separate parts of your app.</p>
<p>This might seem difficult to do, but tools like Webpack have this built in, and React Loadable is designed to make it super simple.</p>
<h3><a class="anchor" id="autotoc_md18272"></a>
Route-based splitting vs. Component-based splitting</h3>
<p>A common piece of advice you will see is to break your app into separate routes and load each one asynchronously. This seems to work well enough for many appsâ€“ as a user, clicking a link and waiting for a page to load is a familiar experience on the web.</p>
<p>But we can do better than that.</p>
<p>Using most routing tools for React, a route is simply a component. There's nothing particularly special about them (Sorry Ryan and Michaelâ€“ you're what's special). So what if we optimized for splitting around components instead of routes? What would that get us?</p>
<p><img src="http://thejameskyle.com/img/react-loadable-component-splitting.png" alt="Route vs. component centric code splitting" class="inline"/></p>
<p>As it turns out: Quite a lot. There are many more places than just routes where you can pretty easily split apart your app. Modals, tabs, and many more UI components hide content until the user has done something to reveal it.</p>
<blockquote class="doxtable">
<p><b>Example:</b> Maybe your app has a map buried inside of a tab component. Why would you load a massive mapping library for the parent route every time when the user may never go to that tab? </p>
</blockquote>
<p>Not to mention all the places where you can defer loading content until higher priority content is finished loading. That component at the bottom of your page which loads a bunch of libraries: Why should that be loaded at the same time as the content at the top?</p>
<p>And because routes are just components, we can still easily code-split at the route level.</p>
<p>Introducing new code-splitting points in your app should be so easy that you don't think twice about it. It should be a matter of changing a few lines of code and everything else should be automated.</p>
<h3><a class="anchor" id="autotoc_md18273"></a>
Introducing React Loadable</h3>
<p>React Loadable is a small library that makes component-centric code splitting incredibly easy in React.</p>
<p><code>Loadable</code> is a higher-order component (a function that creates a component) which lets you dynamically load any module before rendering it into your app.</p>
<p>Let's imagine two components, one that imports and renders another.</p>
<div class="fragment"><div class="line">import Bar from &#39;./components/Bar&#39;;</div>
<div class="line"> </div>
<div class="line">class Foo extends React.Component {</div>
<div class="line">  render() {</div>
<div class="line">    return &lt;Bar/&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Right now we're depending on <code>Bar</code> being imported synchronously via <code>import</code>, but we don't need it until we go to render it. So why don't we just defer that?</p>
<p>Using a <b>dynamic import</b> (<a href="https://github.com/tc39/proposal-dynamic-import">a tc39 proposal currently at Stage 3</a>) we can modify our component to load <code>Bar</code> asynchronously.</p>
<div class="fragment"><div class="line">class MyComponent extends React.Component {</div>
<div class="line">  state = {</div>
<div class="line">    Bar: null</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  componentWillMount() {</div>
<div class="line">    import(&#39;./components/Bar&#39;).then(Bar =&gt; {</div>
<div class="line">      this.setState({ Bar: Bar.default });</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  render() {</div>
<div class="line">    let {Bar} = this.state;</div>
<div class="line">    if (!Bar) {</div>
<div class="line">      return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">    } else {</div>
<div class="line">      return &lt;Bar/&gt;;</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>But that's a whole bunch of work, and it doesn't even handle a bunch of cases. What about when <code>import()</code> fails? What about server-side rendering?</p>
<p>Instead you can use <code>Loadable</code> to abstract away the problem.</p>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line"> </div>
<div class="line">const LoadableBar = Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./components/Bar&#39;),</div>
<div class="line">  loading() {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">class MyComponent extends React.Component {</div>
<div class="line">  render() {</div>
<div class="line">    return &lt;LoadableBar/&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18274"></a>
Automatic code-splitting on <code>import()</code></h3>
<p>When you use <code>import()</code> with Webpack 2+, it will <a href="https://webpack.js.org/guides/code-splitting/">automatically code-split</a> for you with no additional configuration.</p>
<p>This means that you can easily experiment with new code splitting points just by switching to <code>import()</code> and using React Loadable. Figure out what performs best for your app.</p>
<h3><a class="anchor" id="autotoc_md18275"></a>
Creating a great "Loading..." Component</h3>
<p>Rendering a static "Loading..." doesn't communicate enough to the user. You also need to think about error states, timeouts, and making it a nice experience.</p>
<div class="fragment"><div class="line">function Loading() {</div>
<div class="line">  return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./WillFailToLoad&#39;), // oh no!</div>
<div class="line">  loading: Loading,</div>
<div class="line">});</div>
</div><!-- fragment --><p>To make this all nice, your loading component receives a couple different props.</p>
<h4><a class="anchor" id="autotoc_md18276"></a>
Loading error states</h4>
<p>When your [<code>loader</code>](optsloader) fails, your loading component will receive an [<code>error</code>](propserror) prop which will be an <code>Error</code> object (otherwise it will be <code>null</code>).</p>
<div class="fragment"><div class="line">function Loading(props) {</div>
<div class="line">  if (props.error) {</div>
<div class="line">    return &lt;div&gt;Error! &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18277"></a>
Avoiding <em>Flash Of Loading Component</em></h4>
<p>Sometimes components load really quickly (&lt;200ms) and the loading screen only quickly flashes on the screen.</p>
<p>A number of user studies have proven that this causes users to perceive things taking longer than they really have. If you don't show anything, users perceive it as being faster.</p>
<p>So your loading component will also get a `pastDelay` prop which will only be true once the component has taken longer to load than a set delay.</p>
<div class="fragment"><div class="line">function Loading(props) {</div>
<div class="line">  if (props.error) {</div>
<div class="line">    return &lt;div&gt;Error! &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else if (props.pastDelay) {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return null;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This delay defaults to <code>200ms</code> but you can also customize the delay in <code>Loadable</code>.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./components/Bar&#39;),</div>
<div class="line">  loading: Loading,</div>
<div class="line">  delay: 300, // 0.3 seconds</div>
<div class="line">});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18278"></a>
Timing out when the <code>loader</code> is taking too long</h4>
<p>Sometimes network connections suck and never resolve or fail, they just hang there forever. This sucks for the user because they won't know if it should always take this long, or if they should try refreshing.</p>
<p>The loading component will receive a `timedOut` prop which will be set to <code>true</code> when the `loader` has timed out.</p>
<div class="fragment"><div class="line">function Loading(props) {</div>
<div class="line">  if (props.error) {</div>
<div class="line">    return &lt;div&gt;Error! &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else if (props.timedOut) {</div>
<div class="line">    return &lt;div&gt;Taking a long time... &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else if (props.pastDelay) {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return null;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, this feature is disabled by default. To turn it on, you can pass a `timeout` option to <code>Loadable</code>.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./components/Bar&#39;),</div>
<div class="line">  loading: Loading,</div>
<div class="line">  timeout: 10000, // 10 seconds</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18279"></a>
Customizing rendering</h3>
<p>By default <code>Loadable</code> will render the <code>default</code> export of the returned module. If you want to customize this behavior you can use the `render` option.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./my-component&#39;),</div>
<div class="line">  render(loaded, props) {</div>
<div class="line">    let Component = loaded.namedExport;</div>
<div class="line">    return &lt;Component {...props}/&gt;;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18280"></a>
Loading multiple resources</h3>
<p>Technically you can do whatever you want within <code>loader()</code> as long as it returns a promise and you're able to render something. But writing it out can be a bit annoying.</p>
<p>To make it easier to load multiple resources in parallel, you can use `Loadable.Map`.</p>
<div class="fragment"><div class="line">Loadable.Map({</div>
<div class="line">  loader: {</div>
<div class="line">    Bar: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">    i18n: () =&gt; fetch(&#39;./i18n/bar.json&#39;).then(res =&gt; res.json()),</div>
<div class="line">  },</div>
<div class="line">  render(loaded, props) {</div>
<div class="line">    let Bar = loaded.Bar.default;</div>
<div class="line">    let i18n = loaded.i18n;</div>
<div class="line">    return &lt;Bar {...props} i18n={i18n}/&gt;;</div>
<div class="line">  },</div>
<div class="line">});</div>
</div><!-- fragment --><p>When using <code>Loadable.Map</code> the `render()` method is required. It will be passed a <code>loaded</code> param which will be an object matching the shape of your <code>loader</code>.</p>
<h3><a class="anchor" id="autotoc_md18281"></a>
Preloading</h3>
<p>As an optimization, you can also decide to preload a component before it gets rendered.</p>
<p>For example, if you need to load a new component when a button gets pressed, you could start preloading the component when the user hovers over the button.</p>
<p>The component created by <code>Loadable</code> exposes a static `preload` method which does exactly this.</p>
<div class="fragment"><div class="line">const LoadableBar = Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">  loading: Loading,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">class MyComponent extends React.Component {</div>
<div class="line">  state = { showBar: false };</div>
<div class="line"> </div>
<div class="line">  onClick = () =&gt; {</div>
<div class="line">    this.setState({ showBar: true });</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  onMouseOver = () =&gt; {</div>
<div class="line">    LoadableBar.preload();</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  render() {</div>
<div class="line">    return (</div>
<div class="line">      &lt;div&gt;</div>
<div class="line">        &lt;button</div>
<div class="line">          onClick={this.onClick}</div>
<div class="line">          onMouseOver={this.onMouseOver}&gt;</div>
<div class="line">          Show Bar</div>
<div class="line">        &lt;/button&gt;</div>
<div class="line">        {this.state.showBar &amp;&amp; &lt;LoadableBar/&gt;}</div>
<div class="line">      &lt;/div&gt;</div>
<div class="line">    )</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><img src="http://thejameskyle.com/img/react-loadable-ssr.png" alt="SERVER SIDE RENDERING" class="inline"/>   <small>Server-Side Rendering</small> </h2>
<p>When you go to render all these dynamically loaded components, what you'll get is a whole bunch of loading screens.</p>
<p>This really sucks, but the good news is that React Loadable is designed to make server-side rendering work as if nothing is being loaded dynamically.</p>
<p>Here's our starting server using <a href="https://expressjs.com/">Express</a>.</p>
<div class="fragment"><div class="line">import express from &#39;express&#39;;</div>
<div class="line">import React from &#39;react&#39;;</div>
<div class="line">import ReactDOMServer from &#39;react-dom/server&#39;;</div>
<div class="line">import App from &#39;./components/App&#39;;</div>
<div class="line"> </div>
<div class="line">const app = express();</div>
<div class="line"> </div>
<div class="line">app.get(&#39;/&#39;, (req, res) =&gt; {</div>
<div class="line">  res.send(`</div>
<div class="line">    &lt;!doctype html&gt;</div>
<div class="line">    &lt;html lang=&quot;en&quot;&gt;</div>
<div class="line">      &lt;head&gt;...&lt;/head&gt;</div>
<div class="line">      &lt;body&gt;</div>
<div class="line">        &lt;div id=&quot;app&quot;&gt;${ReactDOMServer.renderToString(&lt;App/&gt;)}&lt;/div&gt;</div>
<div class="line">        &lt;script src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">      &lt;/body&gt;</div>
<div class="line">    &lt;/html&gt;</div>
<div class="line">  `);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">app.listen(3000, () =&gt; {</div>
<div class="line">  console.log(&#39;Running on http://localhost:3000/&#39;);</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18282"></a>
Preloading all your loadable components on the server</h3>
<p>The first step to rendering the correct content from the server is to make sure that all of your loadable components are already loaded when you go to render them.</p>
<p>To do this, you can use the `Loadable.preloadAll` method. It returns a promise that will resolve when all your loadable components are ready.</p>
<div class="fragment"><div class="line">Loadable.preloadAll().then(() =&gt; {</div>
<div class="line">  app.listen(3000, () =&gt; {</div>
<div class="line">    console.log(&#39;Running on http://localhost:3000/&#39;);</div>
<div class="line">  });</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18283"></a>
Picking up a server-side rendered app on the client</h3>
<p>This is where things get a little bit tricky. So let's prepare ourselves little bit.</p>
<p>In order for us to pick up what was rendered from the server we need to have all the same code that was used to render on the server.</p>
<p>To do this, we first need our loadable components telling us which modules they are rendering.</p>
<h4><a class="anchor" id="autotoc_md18284"></a>
Declaring which modules are being loaded</h4>
<p>There are two options in `Loadable` and `Loadable.Map` which are used to tell us which modules our component is trying to load: `opts.modules` and `opts.webpack`.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">  modules: [&#39;./Bar&#39;],</div>
<div class="line">  webpack: () =&gt; [require.resolveWeak(&#39;./Bar&#39;)],</div>
<div class="line">});</div>
</div><!-- fragment --><p>But don't worry too much about these options. React Loadable includes a Babel plugin to add them for you.</p>
<p>Just add the <code>react-loadable/babel</code> plugin to your Babel config:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [</div>
<div class="line">    &quot;react-loadable/babel&quot;</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now these options will automatically be provided.</p>
<p>For typescript you can use <a href="https://github.com/stushurik/react-loadable-ts-transformer">react-loadable-ts-transformer</a> which is a ts analog of react-loadable/babel plugin.</p>
<h4><a class="anchor" id="autotoc_md18285"></a>
Finding out which dynamic modules were rendered</h4>
<p>Next we need to find out which modules were actually rendered when a request comes in.</p>
<p>For this, there is `Loadable.Capture` component which can be used to collect all the modules that were rendered.</p>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line"> </div>
<div class="line">app.get(&#39;/&#39;, (req, res) =&gt; {</div>
<div class="line">  let modules = [];</div>
<div class="line"> </div>
<div class="line">  let html = ReactDOMServer.renderToString(</div>
<div class="line">    &lt;Loadable.Capture report={moduleName =&gt; modules.push(moduleName)}&gt;</div>
<div class="line">      &lt;App/&gt;</div>
<div class="line">    &lt;/Loadable.Capture&gt;</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  console.log(modules);</div>
<div class="line"> </div>
<div class="line">  res.send(`...${html}...`);</div>
<div class="line">});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18286"></a>
Mapping loaded modules to bundles</h4>
<p>In order to make sure that the client loads all the modules that were rendered server-side, we'll need to map them to the bundles that Webpack created.</p>
<p>This comes in two parts.</p>
<p>First we need Webpack to tell us which bundles each module lives inside. For this there is the React Loadable Webpack plugin.</p>
<p>Import the <code>ReactLoadablePlugin</code> from <code>react-loadable/webpack</code> and include it in your webpack config. Pass it a <code>filename</code> for where to store the JSON data about our bundles.</p>
<div class="fragment"><div class="line">// webpack.config.js</div>
<div class="line">import { ReactLoadablePlugin } from &#39;react-loadable/webpack&#39;;</div>
<div class="line"> </div>
<div class="line">export default {</div>
<div class="line">  plugins: [</div>
<div class="line">    new ReactLoadablePlugin({</div>
<div class="line">      filename: &#39;./dist/react-loadable.json&#39;,</div>
<div class="line">    }),</div>
<div class="line">  ],</div>
<div class="line">};</div>
</div><!-- fragment --><p>Then we'll go back to our server and use this data to convert our modules to bundles.</p>
<p>To convert from modules to bundles, import the `getBundles` method from <code>react-loadable/webpack</code> and the data from Webpack.</p>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line">import { getBundles } from &#39;react-loadable/webpack&#39;</div>
<div class="line">import stats from &#39;./dist/react-loadable.json&#39;;</div>
<div class="line"> </div>
<div class="line">app.get(&#39;/&#39;, (req, res) =&gt; {</div>
<div class="line">  let modules = [];</div>
<div class="line"> </div>
<div class="line">  let html = ReactDOMServer.renderToString(</div>
<div class="line">    &lt;Loadable.Capture report={moduleName =&gt; modules.push(moduleName)}&gt;</div>
<div class="line">      &lt;App/&gt;</div>
<div class="line">    &lt;/Loadable.Capture&gt;</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  let bundles = getBundles(stats, modules);</div>
<div class="line"> </div>
<div class="line">  // ...</div>
<div class="line">});</div>
</div><!-- fragment --><p>We can then render these bundles into <code>&lt;script&gt;</code> tags in our HTML.</p>
<p>It is important that the bundles are included <em>before</em> the main bundle, so that they can be loaded by the browser prior to the app rendering.</p>
<p>However, as the Webpack manifest (including the logic for parsing bundles) lives in the main bundle, it will need to be extracted into its own chunk.</p>
<p>This is easy to do with the <a href="https://webpack.js.org/plugins/commons-chunk-plugin/">CommonsChunkPlugin</a></p>
<div class="fragment"><div class="line">// webpack.config.js</div>
<div class="line">export default {</div>
<div class="line">  plugins: [</div>
<div class="line">    new webpack.optimize.CommonsChunkPlugin({</div>
<div class="line">      name: &#39;manifest&#39;,</div>
<div class="line">      minChunks: Infinity</div>
<div class="line">    })</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Notice: As of Webpack 4 the CommonsChunkPlugin has been removed and the manifest doesn't need to be extracted anymore.</em></p>
<div class="fragment"><div class="line">let bundles = getBundles(stats, modules);</div>
<div class="line"> </div>
<div class="line">res.send(`</div>
<div class="line">  &lt;!doctype html&gt;</div>
<div class="line">  &lt;html lang=&quot;en&quot;&gt;</div>
<div class="line">    &lt;head&gt;...&lt;/head&gt;</div>
<div class="line">    &lt;body&gt;</div>
<div class="line">      &lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt;</div>
<div class="line">      &lt;script src=&quot;/dist/manifest.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">      &lt;script src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">      ${bundles.map(bundle =&gt; {</div>
<div class="line">        return `&lt;script src=&quot;/dist/${bundle.file}&quot;&gt;&lt;/script&gt;`</div>
<div class="line">        // alternatively if you are using publicPath option in webpack config</div>
<div class="line">        // you can use the publicPath value from bundle, e.g:</div>
<div class="line">        // return `&lt;script src=&quot;${bundle.publicPath}&quot;&gt;&lt;/script&gt;`</div>
<div class="line">      }).join(&#39;\n&#39;)}</div>
<div class="line">      &lt;script&gt;window.main();&lt;/script&gt;</div>
<div class="line">    &lt;/body&gt;</div>
<div class="line">  &lt;/html&gt;</div>
<div class="line">`);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18287"></a>
Preloading ready loadable components on the client</h4>
<p>We can use the `Loadable.preloadReady()` method on the client to preload the loadable components that were included on the page.</p>
<p>Like `Loadable.preloadAll()`, it returns a promise, which on resolution means that we can hydrate our app.</p>
<div class="fragment"><div class="line">// src/entry.js</div>
<div class="line">import React from &#39;react&#39;;</div>
<div class="line">import ReactDOM from &#39;react-dom&#39;;</div>
<div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line">import App from &#39;./components/App&#39;;</div>
<div class="line"> </div>
<div class="line">window.main = () =&gt; {</div>
<div class="line">  Loadable.preloadReady().then(() =&gt; {</div>
<div class="line">    ReactDOM.hydrate(&lt;App/&gt;, document.getElementById(&#39;app&#39;));</div>
<div class="line">  });</div>
<div class="line">};</div>
</div><!-- fragment --><h4 align="center">Now server-side rendering should work perfectly! </h4>
<h2><img src="http://thejameskyle.com/img/react-loadable-api-docs.png" alt="API DOCS" class="inline"/>   <small>API Docs</small> </h2>
<h3><a class="anchor" id="autotoc_md18288"></a>
<code>Loadable</code></h3>
<p>A higher-order component for dynamically loading a module before rendering it, a loading component is rendered while the module is unavailable.</p>
<div class="fragment"><div class="line">const LoadableComponent = Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">  loading: Loading,</div>
<div class="line">  delay: 200,</div>
<div class="line">  timeout: 10000,</div>
<div class="line">});</div>
</div><!-- fragment --><p>This returns a LoadableComponent.</p>
<h3><a class="anchor" id="autotoc_md18289"></a>
<code>Loadable.Map</code></h3>
<p>A higher-order component that allows you to load multiple resources in parallel.</p>
<p>Loadable.Map's `opts.loader` accepts an object of functions, and needs a `opts.render` method.</p>
<div class="fragment"><div class="line">Loadable.Map({</div>
<div class="line">  loader: {</div>
<div class="line">    Bar: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">    i18n: () =&gt; fetch(&#39;./i18n/bar.json&#39;).then(res =&gt; res.json()),</div>
<div class="line">  },</div>
<div class="line">  render(loaded, props) {</div>
<div class="line">    let Bar = loaded.Bar.default;</div>
<div class="line">    let i18n = loaded.i18n;</div>
<div class="line">    return &lt;Bar {...props} i18n={i18n}/&gt;;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>When using <code>Loadable.Map</code> the <code>render()</code> method's <code>loaded</code> param will be an object with the same shape as your <code>loader</code>.</p>
<h3><a class="anchor" id="autotoc_md18290"></a>
<code>Loadable</code> and <code>Loadable.Map</code> Options</h3>
<h4><a class="anchor" id="autotoc_md18291"></a>
<code>opts.loader</code></h4>
<p>A function returning a promise that loads your module.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">});</div>
</div><!-- fragment --><p>When using with `Loadable.Map` this accepts an object of these types of functions.</p>
<div class="fragment"><div class="line">Loadable.Map({</div>
<div class="line">  loader: {</div>
<div class="line">    Bar: () =&gt; import(&#39;./Bar&#39;),</div>
<div class="line">    i18n: () =&gt; fetch(&#39;./i18n/bar.json&#39;).then(res =&gt; res.json()),</div>
<div class="line">  },</div>
<div class="line">});</div>
</div><!-- fragment --><p>When using with <code>Loadable.Map</code> you'll also need to pass a `opts.render` function.</p>
<h4><a class="anchor" id="autotoc_md18292"></a>
<code>opts.loading</code></h4>
<p>A `LoadingComponent` that renders while a module is loading or when it errors.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loading: LoadingComponent,</div>
<div class="line">});</div>
</div><!-- fragment --><p>This option is required, if you don't want to render anything, return <code>null</code>.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loading: () =&gt; null,</div>
<div class="line">});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18293"></a>
<code>opts.delay</code></h4>
<p>Time to wait (in milliseconds) before passing `props.pastDelay` to your `loading` component. This defaults to <code>200</code>.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  delay: 200</div>
<div class="line">});</div>
</div><!-- fragment --><p>Read more about delays.</p>
<h4><a class="anchor" id="autotoc_md18294"></a>
<code>opts.timeout</code></h4>
<p>Time to wait (in milliseconds) before passing `props.timedOut` to your `loading` component. This is turned off by default.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  timeout: 10000</div>
<div class="line">});</div>
</div><!-- fragment --><p>Read more about timeouts.</p>
<h4><a class="anchor" id="autotoc_md18295"></a>
<code>opts.render</code></h4>
<p>A function to customize the rendering of loaded modules.</p>
<p>Receives <code>loaded</code> which is the resolved value of `opts.loader` and <code>props</code> which are the props passed to the `LoadableComponent`.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  render(loaded, props) {</div>
<div class="line">    let Component = loaded.default;</div>
<div class="line">    return &lt;Component {...props}/&gt;;</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18296"></a>
<code>opts.webpack</code></h4>
<p>An optional function which returns an array of Webpack module ids which you can get with <code>require.resolveWeak</code>.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./Foo&#39;),</div>
<div class="line">  webpack: () =&gt; [require.resolveWeak(&#39;./Foo&#39;)],</div>
<div class="line">});</div>
</div><!-- fragment --><p>This option can be automated with the Babel Plugin.</p>
<h4><a class="anchor" id="autotoc_md18297"></a>
<code>opts.modules</code></h4>
<p>An optional array with module paths for your imports.</p>
<div class="fragment"><div class="line">Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./my-component&#39;),</div>
<div class="line">  modules: [&#39;./my-component&#39;],</div>
<div class="line">});</div>
</div><!-- fragment --><p>This option can be automated with the Babel Plugin.</p>
<h3><a class="anchor" id="autotoc_md18298"></a>
<code>LoadableComponent</code></h3>
<p>This is the component returned by <code>Loadable</code> and <code>Loadable.Map</code>.</p>
<div class="fragment"><div class="line">const LoadableComponent = Loadable({</div>
<div class="line">  // ...</div>
<div class="line">});</div>
</div><!-- fragment --><p>Props passed to this component will be passed straight through to the dynamically loaded component via `opts.render`.</p>
<h4><a class="anchor" id="autotoc_md18299"></a>
<code>LoadableComponent.preload()</code></h4>
<p>This is a static method on `LoadableComponent` which can be used to load the component ahead of time.</p>
<div class="fragment"><div class="line">const LoadableComponent = Loadable({...});</div>
<div class="line"> </div>
<div class="line">LoadableComponent.preload();</div>
</div><!-- fragment --><p>This returns a promise, but you should avoid waiting for that promise to resolve to update your UI. In most cases it creates a bad user experience.</p>
<p>Read more about preloading.</p>
<h3><a class="anchor" id="autotoc_md18300"></a>
<code>LoadingComponent</code></h3>
<p>This is the component you pass to `opts.loading`.</p>
<div class="fragment"><div class="line">function LoadingComponent(props) {</div>
<div class="line">  if (props.error) {</div>
<div class="line">    // When the loader has errored</div>
<div class="line">    return &lt;div&gt;Error! &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else if (props.timedOut) {</div>
<div class="line">    // When the loader has taken longer than the timeout</div>
<div class="line">    return &lt;div&gt;Taking a long time... &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else if (props.pastDelay) {</div>
<div class="line">    // When the loader has taken longer than the delay</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    // When the loader has just started</div>
<div class="line">    return null;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Loadable({</div>
<div class="line">  loading: LoadingComponent,</div>
<div class="line">});</div>
</div><!-- fragment --><p>Read more about loading components</p>
<h4><a class="anchor" id="autotoc_md18301"></a>
<code>props.error</code></h4>
<p>An <code>Error</code> object passed to `LoadingComponent` when the `loader` has failed. When there is no error, <code>null</code> is passed.</p>
<div class="fragment"><div class="line">function LoadingComponent(props) {</div>
<div class="line">  if (props.error) {</div>
<div class="line">    return &lt;div&gt;Error!&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Read more about errors.</p>
<h4><a class="anchor" id="autotoc_md18302"></a>
<code>props.retry</code></h4>
<p>A function prop passed to `LoadingComponent` when the `loader` has failed, used to retry loading the component.</p>
<div class="fragment"><div class="line">function LoadingComponent(props) {</div>
<div class="line">  if (props.error) {</div>
<div class="line">    return &lt;div&gt;Error! &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Read more about errors.</p>
<h4><a class="anchor" id="autotoc_md18303"></a>
<code>props.timedOut</code></h4>
<p>A boolean prop passed to `LoadingComponent` after a set `timeout`.</p>
<div class="fragment"><div class="line">function LoadingComponent(props) {</div>
<div class="line">  if (props.timedOut) {</div>
<div class="line">    return &lt;div&gt;Taking a long time...&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Read more about timeouts.</p>
<h4><a class="anchor" id="autotoc_md18304"></a>
<code>props.pastDelay</code></h4>
<p>A boolean prop passed to `LoadingComponent` after a set `delay`.</p>
<div class="fragment"><div class="line">function LoadingComponent(props) {</div>
<div class="line">  if (props.pastDelay) {</div>
<div class="line">    return &lt;div&gt;Loading...&lt;/div&gt;;</div>
<div class="line">  } else {</div>
<div class="line">    return null;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Read more about delays.</p>
<h3><a class="anchor" id="autotoc_md18305"></a>
<code>Loadable.preloadAll()</code></h3>
<p>This will call all of the `LoadableComponent.preload` methods recursively until they are all resolved. Allowing you to preload all of your dynamic modules in environments like the server.</p>
<div class="fragment"><div class="line">Loadable.preloadAll().then(() =&gt; {</div>
<div class="line">  app.listen(3000, () =&gt; {</div>
<div class="line">    console.log(&#39;Running on http://localhost:3000/&#39;);</div>
<div class="line">  });</div>
<div class="line">});</div>
</div><!-- fragment --><p>It's important to note that this requires that you declare all of your loadable components when modules are initialized rather than when your app is being rendered.</p>
<p><b>Good:</b></p>
<div class="fragment"><div class="line">// During module initialization...</div>
<div class="line">const LoadableComponent = Loadable({...});</div>
<div class="line"> </div>
<div class="line">class MyComponent extends React.Component {</div>
<div class="line">  componentDidMount() {</div>
<div class="line">    // ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Bad:</b></p>
<div class="fragment"><div class="line">// ...</div>
<div class="line"> </div>
<div class="line">class MyComponent extends React.Component {</div>
<div class="line">  componentDidMount() {</div>
<div class="line">    // During app render...</div>
<div class="line">    const LoadableComponent = Loadable({...});</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>Note:</b> <code>Loadable.preloadAll()</code> will not work if you have more than one copy of <code>react-loadable</code> in your app. </p>
</blockquote>
<p>Read more about preloading on the server.</p>
<h3><a class="anchor" id="autotoc_md18306"></a>
<code>Loadable.preloadReady()</code></h3>
<p>Check for modules that are already loaded in the browser and call the matching `LoadableComponent.preload` methods.</p>
<div class="fragment"><div class="line">Loadable.preloadReady().then(() =&gt; {</div>
<div class="line">  ReactDOM.hydrate(&lt;App/&gt;, document.getElementById(&#39;app&#39;));</div>
<div class="line">});</div>
</div><!-- fragment --><p>Read more about preloading on the client.</p>
<h3><a class="anchor" id="autotoc_md18307"></a>
<code>Loadable.Capture</code></h3>
<p>A component for reporting which modules were rendered.</p>
<p>Accepts a <code>report</code> prop which is called for every <code>moduleName</code> that is rendered via React Loadable.</p>
<div class="fragment"><div class="line">let modules = [];</div>
<div class="line"> </div>
<div class="line">let html = ReactDOMServer.renderToString(</div>
<div class="line">  &lt;Loadable.Capture report={moduleName =&gt; modules.push(moduleName)}&gt;</div>
<div class="line">    &lt;App/&gt;</div>
<div class="line">  &lt;/Loadable.Capture&gt;</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">console.log(modules);</div>
</div><!-- fragment --><p>Read more about capturing rendered modules.</p>
<h2><a class="anchor" id="autotoc_md18308"></a>
Babel Plugin</h2>
<p>Providing `opts.webpack` and `opts.modules` for every loadable component is a lot of manual work to remember to do.</p>
<p>Instead you can add the Babel plugin to your config and it will automate it for you:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;plugins&quot;: [&quot;react-loadable/babel&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Input</b></p>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line"> </div>
<div class="line">const LoadableMyComponent = Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./MyComponent&#39;),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const LoadableComponents = Loadable.Map({</div>
<div class="line">  loader: {</div>
<div class="line">    One: () =&gt; import(&#39;./One&#39;),</div>
<div class="line">    Two: () =&gt; import(&#39;./Two&#39;),</div>
<div class="line">  },</div>
<div class="line">});</div>
</div><!-- fragment --><p><b>Output</b></p>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line">import path from &#39;path&#39;;</div>
<div class="line"> </div>
<div class="line">const LoadableMyComponent = Loadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./MyComponent&#39;),</div>
<div class="line">  webpack: () =&gt; [require.resolveWeak(&#39;./MyComponent&#39;)],</div>
<div class="line">  modules: [path.join(__dirname, &#39;./MyComponent&#39;)],</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const LoadableComponents = Loadable.Map({</div>
<div class="line">  loader: {</div>
<div class="line">    One: () =&gt; import(&#39;./One&#39;),</div>
<div class="line">    Two: () =&gt; import(&#39;./Two&#39;),</div>
<div class="line">  },</div>
<div class="line">  webpack: () =&gt; [require.resolveWeak(&#39;./One&#39;), require.resolveWeak(&#39;./Two&#39;)],</div>
<div class="line">  modules: [path.join(__dirname, &#39;./One&#39;), path.join(__dirname, &#39;./Two&#39;)],</div>
<div class="line">});</div>
</div><!-- fragment --><p>Read more about declaring modules.</p>
<h2><a class="anchor" id="autotoc_md18309"></a>
Webpack Plugin</h2>
<p>In order to send the right bundles down when rendering server-side, you'll need the React Loadable Webpack pluginÂ  to provide you with a mapping of modules to bundles.</p>
<div class="fragment"><div class="line">// webpack.config.js</div>
<div class="line">import { ReactLoadablePlugin } from &#39;react-loadable/webpack&#39;;</div>
<div class="line"> </div>
<div class="line">export default {</div>
<div class="line">  plugins: [</div>
<div class="line">    new ReactLoadablePlugin({</div>
<div class="line">      filename: &#39;./dist/react-loadable.json&#39;,</div>
<div class="line">    }),</div>
<div class="line">  ],</div>
<div class="line">};</div>
</div><!-- fragment --><p>This will create a file (<code>opts.filename</code>) which you can import to map modules to bundles.</p>
<p>Read more about mapping modules to bundles.</p>
<h3><a class="anchor" id="autotoc_md18310"></a>
<code>getBundles</code></h3>
<p>A method exported by <code>react-loadable/webpack</code> for converting modules to bundles.</p>
<div class="fragment"><div class="line">import { getBundles } from &#39;react-loadable/webpack&#39;;</div>
<div class="line"> </div>
<div class="line">let bundles = getBundles(stats, modules);</div>
</div><!-- fragment --><p>Read more about mapping modules to bundles.</p>
<h2><img src="http://thejameskyle.com/img/react-loadable-faq.png" alt="FAQ" class="inline"/>   <small>FAQ</small> </h2>
<h3><a class="anchor" id="autotoc_md18311"></a>
How do I avoid repetition?</h3>
<p>Specifying the same <code>loading</code> component or <code>delay</code> every time you use <code>Loadable()</code> gets repetitive fast. Instead you can wrap <code>Loadable</code> with your own Higher-Order Component (HOC) to set default options.</p>
<div class="fragment"><div class="line">import Loadable from &#39;react-loadable&#39;;</div>
<div class="line">import Loading from &#39;./my-loading-component&#39;;</div>
<div class="line"> </div>
<div class="line">export default function MyLoadable(opts) {</div>
<div class="line">  return Loadable(Object.assign({</div>
<div class="line">    loading: Loading,</div>
<div class="line">    delay: 200,</div>
<div class="line">    timeout: 10000,</div>
<div class="line">  }, opts));</div>
<div class="line">};</div>
</div><!-- fragment --><p>Then you can just specify a <code>loader</code> when you go to use it.</p>
<div class="fragment"><div class="line">import MyLoadable from &#39;./MyLoadable&#39;;</div>
<div class="line"> </div>
<div class="line">const LoadableMyComponent = MyLoadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./MyComponent&#39;),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">export default class App extends React.Component {</div>
<div class="line">  render() {</div>
<div class="line">    return &lt;LoadableMyComponent/&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Unfortunately at the moment using wrapped Loadable breaks react-loadable/babel so in such case you have to add required properties (<code>modules</code>, <code>webpack</code>) manually.</p>
<div class="fragment"><div class="line">import MyLoadable from &#39;./MyLoadable&#39;;</div>
<div class="line"> </div>
<div class="line">const LoadableMyComponent = MyLoadable({</div>
<div class="line">  loader: () =&gt; import(&#39;./MyComponent&#39;),</div>
<div class="line">  modules: [&#39;./MyComponent&#39;],</div>
<div class="line">  webpack: () =&gt; [require.resolveWeak(&#39;./MyComponent&#39;)],</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">export default class App extends React.Component {</div>
<div class="line">  render() {</div>
<div class="line">    return &lt;LoadableMyComponent/&gt;;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18312"></a>
How do I handle other styles <code>.css</code> or sourcemaps <code>.map</code> with server-side rendering?</h3>
<p>When you call `getBundles`, it may return file types other than JavaScript depending on your Webpack configuration.</p>
<p>To handle this, you should manually filter down to the file extensions that you care about:</p>
<div class="fragment"><div class="line">let bundles = getBundles(stats, modules);</div>
<div class="line"> </div>
<div class="line">let styles = bundles.filter(bundle =&gt; bundle.file.endsWith(&#39;.css&#39;));</div>
<div class="line">let scripts = bundles.filter(bundle =&gt; bundle.file.endsWith(&#39;.js&#39;));</div>
<div class="line"> </div>
<div class="line">res.send(`</div>
<div class="line">  &lt;!doctype html&gt;</div>
<div class="line">  &lt;html lang=&quot;en&quot;&gt;</div>
<div class="line">    &lt;head&gt;</div>
<div class="line">      ...</div>
<div class="line">      ${styles.map(style =&gt; {</div>
<div class="line">        return `&lt;link href=&quot;/dist/${style.file}&quot; rel=&quot;stylesheet&quot;/&gt;`</div>
<div class="line">      }).join(&#39;\n&#39;)}</div>
<div class="line">    &lt;/head&gt;</div>
<div class="line">    &lt;body&gt;</div>
<div class="line">      &lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt;</div>
<div class="line">      &lt;script src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">      ${scripts.map(script =&gt; {</div>
<div class="line">        return `&lt;script src=&quot;/dist/${script.file}&quot;&gt;&lt;/script&gt;`</div>
<div class="line">      }).join(&#39;\n&#39;)}</div>
<div class="line">    &lt;/body&gt;</div>
<div class="line">  &lt;/html&gt;</div>
<div class="line">`);</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_49e56c817e5e54854c35e136979f97ca.html">docs</a></li><li class="navelem"><a class="el" href="dir_a0409b32ef7fd26e7246cf83548265be.html">node_modules</a></li><li class="navelem"><a class="el" href="dir_44fd45c7ceed4ff3da754dc89f22dc49.html">react-loadable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
